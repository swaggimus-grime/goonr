// This file is @generated by brush-wgsl from source wgsl files. Do not edit.
#![allow(dead_code, unused_mut, trivial_numeric_casts)]
#![allow(clippy::all)]
#![allow(clippy::derive_partial_eq_without_eq)]
#[rustfmt::skip]
fn create_composer() -> naga_oil::compose::Composer {
    let mut composer = naga_oil::compose::Composer::default().with_capabilities(
            naga::valid::Capabilities::all()
        );
    composer.add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
        source: include_str!("./helpers.wgsl"),
        file_path: "helpers.wgsl",
        as_name: Some("helpers".to_owned()),
        ..Default::default()
    }).expect("Failed to add module");
    composer
}
#[rustfmt::skip]
pub mod helpers {
    pub const COV_BLUR: f32 = 0.3 as f32;
    #[repr(C, align(4))]
    #[derive(bytemuck::Pod, bytemuck::Zeroable, Debug, PartialEq, Clone, Copy)]
    pub struct PackedVec3 {
            pub x: f32,
            pub y: f32,
            pub z: f32,
    }
    #[repr(C, align(4))]
    #[derive(bytemuck::Pod, bytemuck::Zeroable, Debug, PartialEq, Clone, Copy)]
    pub struct ProjectedSplat {
            pub xy_x: f32,
            pub xy_y: f32,
            pub conic_x: f32,
            pub conic_y: f32,
            pub conic_z: f32,
            pub color_r: f32,
            pub color_g: f32,
            pub color_b: f32,
            pub color_a: f32,
    }
    #[repr(C, align(16))]
    #[derive(bytemuck::Pod, bytemuck::Zeroable, Debug, PartialEq, Clone, Copy)]
    pub struct RenderUniforms {
            pub viewmat: [[f32; 4]; 4],
            pub focal: [f32; 2],
            pub img_size: [u32; 2],
            pub tile_bounds: [u32; 2],
            pub pixel_center: [f32; 2],
            pub camera_position: [f32; 4],
            pub sh_degree: u32,
            pub num_visible: i32,
            pub total_splats: u32,
            pub max_intersects: u32,
            pub background: [f32; 4],
    }
    pub const TILE_SIZE: u32 = 256;
    pub const TILE_WIDTH: u32 = 16;
}
#[rustfmt::skip]
pub mod map_gaussian_to_intersects {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("map_gaussian_to_intersects.wgsl"),
            file_path: "map_gaussian_to_intersects.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod project_forward {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("project_forward.wgsl"),
            file_path: "project_forward.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod project_visible {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    #[repr(C, align(4))]
    #[derive(bytemuck::Pod, bytemuck::Zeroable, Debug, PartialEq, Clone, Copy)]
    pub struct IsectInfo {
            pub compact_gid: i32,
            pub tile_id: i32,
    }
    pub const SH_C0: f32 = 0.2820948 as f32;
    #[repr(C, align(16))]
    #[derive(bytemuck::Pod, bytemuck::Zeroable, Debug, PartialEq, Clone, Copy)]
    pub struct ShCoeffs {
            pub b0_c0: [f32; 4],
            pub b1_c0: [f32; 4],
            pub b1_c1: [f32; 4],
            pub b1_c2: [f32; 4],
            pub b2_c0: [f32; 4],
            pub b2_c1: [f32; 4],
            pub b2_c2: [f32; 4],
            pub b2_c3: [f32; 4],
            pub b2_c4: [f32; 4],
            pub b3_c0: [f32; 4],
            pub b3_c1: [f32; 4],
            pub b3_c2: [f32; 4],
            pub b3_c3: [f32; 4],
            pub b3_c4: [f32; 4],
            pub b3_c5: [f32; 4],
            pub b3_c6: [f32; 4],
            pub b4_c0: [f32; 4],
            pub b4_c1: [f32; 4],
            pub b4_c2: [f32; 4],
            pub b4_c3: [f32; 4],
            pub b4_c4: [f32; 4],
            pub b4_c5: [f32; 4],
            pub b4_c6: [f32; 4],
            pub b4_c7: [f32; 4],
            pub b4_c8: [f32; 4],
    }
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("project_visible.wgsl"),
            file_path: "project_visible.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod rasterize {
    pub const WORKGROUP_SIZE: [u32; 3] = [16, 16, 1];
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("rasterize.wgsl"),
            file_path: "rasterize.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
