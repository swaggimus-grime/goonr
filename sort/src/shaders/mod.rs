// This file is @generated by brush-wgsl from source wgsl files. Do not edit.
#![allow(dead_code, unused_mut, trivial_numeric_casts)]
#![allow(clippy::all)]
#![allow(clippy::derive_partial_eq_without_eq)]
#[rustfmt::skip]
fn create_composer() -> naga_oil::compose::Composer {
    let mut composer = naga_oil::compose::Composer::default().with_capabilities(
            naga::valid::Capabilities::all()
        );
    composer.add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
        source: include_str!("./sorting.wgsl"),
        file_path: "sorting.wgsl",
        as_name: Some("sorting".to_owned()),
        ..Default::default()
    }).expect("Failed to add module");
    composer
}
#[rustfmt::skip]
pub mod sort_count {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    #[repr(C, align(4))]
    #[derive(bytemuck::Pod, bytemuck::Zeroable, Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
            pub shift: u32,
    }
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("sort_count.wgsl"),
            file_path: "sort_count.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod sort_reduce {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("sort_reduce.wgsl"),
            file_path: "sort_reduce.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod sort_scan {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("sort_scan.wgsl"),
            file_path: "sort_scan.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod sort_scan_add {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("sort_scan_add.wgsl"),
            file_path: "sort_scan_add.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod sort_scatter {
    pub const WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    #[repr(C, align(4))]
    #[derive(bytemuck::Pod, bytemuck::Zeroable, Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
            pub shift: u32,
    }
    
    pub(crate) fn create_shader_source(
       shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>
    ) -> naga::Module {
        super::create_composer().make_naga_module(naga_oil::compose::NagaModuleDescriptor {
            source: include_str!("sort_scatter.wgsl"),
            file_path: "sort_scatter.wgsl",
            shader_defs,
            ..Default::default()
        }).expect("Failed to add module")
    }
}
#[rustfmt::skip]
pub mod sorting {
    pub const BIN_COUNT: u32 = 16;
    pub const BITS_PER_PASS: u32 = 4;
    pub const BLOCK_SIZE: u32 = 1024;
    pub const ELEMENTS_PER_THREAD: u32 = 4;
    pub const WG: u32 = 256;
}
